---
title: An R Markdown document converted from "Demo2.ipynb"
output: html_document
---

# Applying functions in R

Installing to read Excel files:

```{r}
# install.packages('rio')
```

# reading data

```{r}
# I use the below code to read the Excel spreadsheet from Github into my R notebook
linkGit="https://github.com/Fundamentals-Sarah/HW2/raw/refs/heads/main/FSI-2023-DOWNLOAD.xlsx"

# I install the needed package, rio
fragility23=rio::import(file = linkGit) 
```

```{r}
# I use the str function to give me a high-level overview of what my data frame contains for data
str(fragility23) 
```

## Apply square root function?

```{r}
# I ask R to produce a square root for the entire data frame, which it cannot do because non-numeric variables are in the data frame
# sqrt(fragility23) - Submitting as a note because my R gives me an error when knitting to HTML as code
```

```{r}
# I ask R to produce a squareroot for all the numbers in columns 4 and 5, Total and Demographic Pressures. It can do this because these are numeric variables.
sqrt(fragility23[,4:5]) 
```

```{r}
# I ask R to produce the square root for numbers in just one column, column 4 for Total, by using not the column not but instead the column name.
sqrt(fragility23$Total) 
```

```{r}
# I ask R to produce the square root for the first value in column for Total
sqrt(fragility23$Total[1]) 
```

## Applying **sum()**:

```{r}
# I produce a sum of all numbers in columns 4 and 5.
sum(fragility23[,4:5]) 
```

```{r}
# I use apply with the sum function to get a sum for column 4 and a sum for column 5. Apply allows me to apply the function to each of the columns separately.
print(apply(fragility23[,4:5],2,sum)) 
```

```{r}
# I use the type of apply function to tell me what type of list or vector the data is for the output of sum of column 4 and the sum of column 5. If I do not see list in the output, then it is a type of vector.
typeof(apply(fragility23[,4:5],2,sum)) 
```

```{r}
# I use print apply function to generate a sum of columns 4 and 5 by row.
print(apply(fragility23[,4:5],1,sum)) 
```

### Apply by iterating:

```{r}
# I use lapply to get the sum of columns 4 and the sum of column 5.
print(lapply(fragility23[,4:5],sum))
```

Notice output of **lapply**:

```{r}
# I use type of to determine whether the output is a list or a vector. Because it is lapply, it only works by column, so it is a list.
typeof(lapply(fragility23[,4:5],sum))
```

```{r}
# I determine what kind of class lapply sum of columns 4 and 5 is. It is a list.
class(lapply(fragility23[,4:5],sum))
```

Notice output of **sapply**:

```{r}
# I use sapply to generate again the sum of column 4 and the sum of column 5.
print(sapply(fragility23[,4:5],sum))
```

```{r}
#I want to know the class of the sapply output above - it is numeric, or a vector.
class(sapply(fragility23[,4:5],sum))
```

```{r}
# I generate again the square root of all numbers in columns 4 and 5 using lapply.
print(lapply(fragility23[,4:5],sqrt))
```

```{r}
# I produce the class of output for lapply function above, and it is a list.
class(lapply(fragility23[,4:5],sqrt))
```

```{r}
# Here, I use sapply to generate the square root for each number in columns 4 and 5.
print(sapply(fragility23[,4:5],sqrt))
```

```{r}
# I assess the class of sapply output of square root for all numbers in column 4 and column 5, and it is a matrix.
class(sapply(fragility23[,4:5],sqrt))
```

# Using Own Functions

```{r}
#I define the function name 
theOnesOK = function(DF_country_and_variable) { 
  variable_values <- DF_country_and_variable[,2] # I define that two variables or columns should be pulled into this function
  avg_value <- mean(variable_values, na.rm = TRUE) #I specify how to calculate the mean of the variable, specifying to include null values
  is_above <- ifelse(variable_values > avg_value, "Above Average", "Below/At Average") #I define what counts as above average, otherwise it is below average
  DF_country_and_variable$Status <- is_above #I specify a column of status for showing above and below average
  return(DF_country_and_variable)
  } 
#I set the overall output for the function
```

```{r}
theOnesOK(fragility23[,c('Country','S1: Demographic Pressures')])
```

```{r}
mystery=function(DF,positionsToUse,CountryColumn='Country'){ #I define a function named mystery that pulls in the Country column into the data frame
  newDF=DF[,c(CountryColumn),drop = FALSE] #I specify that the data frame should not exclude any countries
  average='average' #I define what average means
  newDF[,average]=apply(DF[,positionsToUse],1,mean,na.rm = TRUE) #I specify that the new data frame should find the average including values that are null
  return(newDF[,c(CountryColumn,average)])
  } 
# I define the overall output of Country and average for the data frame
```

```{r}
mystery(fragility23,4:6) # I apply the mystery function to produce a data frame that includes Country and also a new column for the average of columns 4, 5, and 6. 
```
# Exercise 1
```{r}
#I define the function theOnesOK2 which includes a variable and a Country column
theOnesOK2 = function(DF, DFvariable, CountryColumn='Country') {
  variable_values <- DF[,DFvariable]
  #I create a new variable called variable values from DFvariable
  avg_value <- mean(variable_values, na.rm = TRUE)
  #I define the average value as the mean of variable values, including nulls within the mean calculation
  is_above <- ifelse(variable_values > avg_value, "Above Average", "Below/At Average")
  #I specify that values above the mean are considered Above Average, and all other values are Below/At Average
  newname = paste('Status_on', DFvariable)
  #I define newname, which will add or concatenate the character string 'Status_on' to the data in DFvariable
  DF[,newname] <- is_above 
  #I will apply is_above logic to newname
  return(DF[,c(CountryColumn, newname)])
} #I specify the return of this function to include Country column and new name
```

```{r}
#As we can see below, theOnesOK2 differs from the theOnesOK by generating a column for Above Average / Below or At Average for Demographic Pressures, without showing those average calculations. The column name appends "Status_on" to the name of the variable being assessed - in this case, generating 'Status_on S1: Demographic Pressures'. The Country column is also automatically pulled in.
theOnesOK2(fragility23, 'S1: Demographic Pressures')
```

# Exercise 2
```{r}
#I define a function named mistery that pulls in the Country column into the data frame and defines certain columns to be pulled in as 'positionstoUse'
mistery = function(DF, positionsToUse, CountryColumn='Country') { 
  newDF = DF[,c(CountryColumn), drop = FALSE] # I specify that the data frame should not exclude any countries
  average = 'average' # I define what the average means
  newDF[,average] = apply(DF[,positionsToUse], 1, mean, na.rm = TRUE) # I specify that the new data frame should find the average of columns in 'position to use', including values that are null, and present these in a column titled average
  return(newDF[,c(CountryColumn, average)])
  }
# I define the overall output of Country and average for the data frame
```

```{r}
#I create a data frame of mistery that shows the country and average for columns 5, 6, 7, 8 and 9. 
mistery(fragility23, 5:9)
```